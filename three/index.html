<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" />
		<title>Taller Three.js</title>
		<style>
			html, body {
  				margin: 0;
  				height: 100%;
			}
			#c {
  				width: 100%;
  				height: 100%;
  				display: block;
			}
		</style>
	</head>
	<body>
		<canvas id="c"></canvas>
			  
	</body>
		
	<script type="module">

		import * as THREE from 'https://threejsfundamentals.org/threejs/resources/threejs/r132/build/three.module.js';
		import {OrbitControls} from 'https://threejsfundamentals.org/threejs/resources/threejs/r132/examples/jsm/controls/OrbitControls.js';
		import {GUI} from 'https://threejsfundamentals.org/threejs/../3rdparty/dat.gui.module.js';

		function main() {
			const canvas = document.querySelector('#c');
  			const renderer = new THREE.WebGLRenderer({canvas});

			const fov = 45;
  			const aspect = 2; 
  			const near = 0.1;
  			const far = 100;
  			const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
  			camera.position.set(0, 10, 20);

			class MinMaxGUIHelper {

   				constructor(obj, minProp, maxProp, minDif) {
   					this.obj = obj;
   					this.minProp = minProp;
   					this.maxProp = maxProp;
    				this.minDif = minDif;
    			}

    			get min() {
      				return this.obj[this.minProp];
    			}
    			
				set min(v) {
      				this.obj[this.minProp] = v;
      				this.obj[this.maxProp] = Math.max(this.obj[this.maxProp], v + this.minDif);
    			}
    
				get max() {
      				return this.obj[this.maxProp];
    			}
    
				set max(v) {
      				this.obj[this.maxProp] = v;
      				this.min = this.min;  // this will call the min setter
    			}
  			}

			function updateCamera() {
    			camera.updateProjectionMatrix();
  			}

			const gui = new GUI();
  			gui.add(camera, 'fov', 1, 180).onChange(updateCamera);
  			const minMaxGUIHelper = new MinMaxGUIHelper(camera, 'near', 'far', 0.1);
  			gui.add(minMaxGUIHelper, 'min', 0.1, 50, 0.1).name('near').onChange(updateCamera);
  			gui.add(minMaxGUIHelper, 'max', 0.1, 50, 0.1).name('far').onChange(updateCamera);

			const controls = new OrbitControls(camera, canvas);
			controls.target.set(0, 5, 0);
			controls.update();

			const scene = new THREE.Scene();
  			scene.background = new THREE.Color('black');

			const cubeSize = 4;
    		const geometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
			const material = new THREE.MeshBasicMaterial({ color: 0x3cbfb7 });

			const cube = new THREE.Mesh(geometry, material);
			scene.add(cube);

			function resizeRendererToDisplaySize(renderer) {
    			const canvas = renderer.domElement;
    			const width = canvas.clientWidth;
    			const height = canvas.clientHeight;
    			const needResize = canvas.width !== width || canvas.height !== height;
    			if (needResize) {
      				renderer.setSize(width, height, false);
    			}
    			return needResize;
  			}

			function render() {

				if (resizeRendererToDisplaySize(renderer)) {
  					const canvas = renderer.domElement;
  					camera.aspect = canvas.clientWidth / canvas.clientHeight;
  					camera.updateProjectionMatrix();
				}

				renderer.render(scene, camera);

				requestAnimationFrame(render);
			}

			//requestAnimationFrame(render);
			const animate = function () {
				requestAnimationFrame(animate);
				cube.rotation.x += 0.01;
				cube.rotation.y += 0.01;
				renderer.render(scene, camera);
			};
			animate();

		}

		main(); 
	</script>
</html>
